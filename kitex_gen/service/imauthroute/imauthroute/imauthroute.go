// Code generated by Kitex v0.9.1. DO NOT EDIT.

package imauthroute

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
	imauthroute "pigeon/kitex_gen/service/imauthroute"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"Login": kitex.NewMethodInfo(
		loginHandler,
		newLoginArgs,
		newLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Logout": kitex.NewMethodInfo(
		logoutHandler,
		newLogoutArgs,
		newLogoutResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ForceOffline": kitex.NewMethodInfo(
		forceOfflineHandler,
		newForceOfflineArgs,
		newForceOfflineResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QuerySessionRoute": kitex.NewMethodInfo(
		querySessionRouteHandler,
		newQuerySessionRouteArgs,
		newQuerySessionRouteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QueryUserRoute": kitex.NewMethodInfo(
		queryUserRouteHandler,
		newQueryUserRouteArgs,
		newQueryUserRouteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	iMAuthRouteServiceInfo                = NewServiceInfo()
	iMAuthRouteServiceInfoForClient       = NewServiceInfoForClient()
	iMAuthRouteServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return iMAuthRouteServiceInfo
}

// for client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return iMAuthRouteServiceInfoForStreamClient
}

// for stream client
func serviceInfoForClient() *kitex.ServiceInfo {
	return iMAuthRouteServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "IMAuthRoute"
	handlerType := (*imauthroute.IMAuthRoute)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "imauthroute",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.9.1",
		Extra:           extra,
	}
	return svcInfo
}

func loginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(imauthroute.LoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(imauthroute.IMAuthRoute).Login(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LoginArgs:
		success, err := handler.(imauthroute.IMAuthRoute).Login(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLoginArgs() interface{} {
	return &LoginArgs{}
}

func newLoginResult() interface{} {
	return &LoginResult{}
}

type LoginArgs struct {
	Req *imauthroute.LoginReq
}

func (p *LoginArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(imauthroute.LoginReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *LoginArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *LoginArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *LoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LoginArgs) Unmarshal(in []byte) error {
	msg := new(imauthroute.LoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LoginArgs_Req_DEFAULT *imauthroute.LoginReq

func (p *LoginArgs) GetReq() *imauthroute.LoginReq {
	if !p.IsSetReq() {
		return LoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LoginResult struct {
	Success *imauthroute.LoginResp
}

var LoginResult_Success_DEFAULT *imauthroute.LoginResp

func (p *LoginResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(imauthroute.LoginResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *LoginResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *LoginResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *LoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LoginResult) Unmarshal(in []byte) error {
	msg := new(imauthroute.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LoginResult) GetSuccess() *imauthroute.LoginResp {
	if !p.IsSetSuccess() {
		return LoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*imauthroute.LoginResp)
}

func (p *LoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginResult) GetResult() interface{} {
	return p.Success
}

func logoutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(imauthroute.LogoutReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(imauthroute.IMAuthRoute).Logout(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LogoutArgs:
		success, err := handler.(imauthroute.IMAuthRoute).Logout(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LogoutResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLogoutArgs() interface{} {
	return &LogoutArgs{}
}

func newLogoutResult() interface{} {
	return &LogoutResult{}
}

type LogoutArgs struct {
	Req *imauthroute.LogoutReq
}

func (p *LogoutArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(imauthroute.LogoutReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *LogoutArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *LogoutArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *LogoutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LogoutArgs) Unmarshal(in []byte) error {
	msg := new(imauthroute.LogoutReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LogoutArgs_Req_DEFAULT *imauthroute.LogoutReq

func (p *LogoutArgs) GetReq() *imauthroute.LogoutReq {
	if !p.IsSetReq() {
		return LogoutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LogoutArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LogoutArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LogoutResult struct {
	Success *imauthroute.LogoutResp
}

var LogoutResult_Success_DEFAULT *imauthroute.LogoutResp

func (p *LogoutResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(imauthroute.LogoutResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *LogoutResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *LogoutResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *LogoutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LogoutResult) Unmarshal(in []byte) error {
	msg := new(imauthroute.LogoutResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LogoutResult) GetSuccess() *imauthroute.LogoutResp {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LogoutResult) SetSuccess(x interface{}) {
	p.Success = x.(*imauthroute.LogoutResp)
}

func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) GetResult() interface{} {
	return p.Success
}

func forceOfflineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(imauthroute.ForceOfflineReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(imauthroute.IMAuthRoute).ForceOffline(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ForceOfflineArgs:
		success, err := handler.(imauthroute.IMAuthRoute).ForceOffline(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ForceOfflineResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newForceOfflineArgs() interface{} {
	return &ForceOfflineArgs{}
}

func newForceOfflineResult() interface{} {
	return &ForceOfflineResult{}
}

type ForceOfflineArgs struct {
	Req *imauthroute.ForceOfflineReq
}

func (p *ForceOfflineArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(imauthroute.ForceOfflineReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ForceOfflineArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ForceOfflineArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ForceOfflineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ForceOfflineArgs) Unmarshal(in []byte) error {
	msg := new(imauthroute.ForceOfflineReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ForceOfflineArgs_Req_DEFAULT *imauthroute.ForceOfflineReq

func (p *ForceOfflineArgs) GetReq() *imauthroute.ForceOfflineReq {
	if !p.IsSetReq() {
		return ForceOfflineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ForceOfflineArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ForceOfflineArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ForceOfflineResult struct {
	Success *imauthroute.ForceOfflineResp
}

var ForceOfflineResult_Success_DEFAULT *imauthroute.ForceOfflineResp

func (p *ForceOfflineResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(imauthroute.ForceOfflineResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ForceOfflineResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ForceOfflineResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ForceOfflineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ForceOfflineResult) Unmarshal(in []byte) error {
	msg := new(imauthroute.ForceOfflineResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ForceOfflineResult) GetSuccess() *imauthroute.ForceOfflineResp {
	if !p.IsSetSuccess() {
		return ForceOfflineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ForceOfflineResult) SetSuccess(x interface{}) {
	p.Success = x.(*imauthroute.ForceOfflineResp)
}

func (p *ForceOfflineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForceOfflineResult) GetResult() interface{} {
	return p.Success
}

func querySessionRouteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(imauthroute.QuerySessionRouteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(imauthroute.IMAuthRoute).QuerySessionRoute(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QuerySessionRouteArgs:
		success, err := handler.(imauthroute.IMAuthRoute).QuerySessionRoute(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QuerySessionRouteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQuerySessionRouteArgs() interface{} {
	return &QuerySessionRouteArgs{}
}

func newQuerySessionRouteResult() interface{} {
	return &QuerySessionRouteResult{}
}

type QuerySessionRouteArgs struct {
	Req *imauthroute.QuerySessionRouteReq
}

func (p *QuerySessionRouteArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(imauthroute.QuerySessionRouteReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *QuerySessionRouteArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *QuerySessionRouteArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *QuerySessionRouteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QuerySessionRouteArgs) Unmarshal(in []byte) error {
	msg := new(imauthroute.QuerySessionRouteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QuerySessionRouteArgs_Req_DEFAULT *imauthroute.QuerySessionRouteReq

func (p *QuerySessionRouteArgs) GetReq() *imauthroute.QuerySessionRouteReq {
	if !p.IsSetReq() {
		return QuerySessionRouteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QuerySessionRouteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QuerySessionRouteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QuerySessionRouteResult struct {
	Success *imauthroute.QuerySessionRouteResp
}

var QuerySessionRouteResult_Success_DEFAULT *imauthroute.QuerySessionRouteResp

func (p *QuerySessionRouteResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(imauthroute.QuerySessionRouteResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *QuerySessionRouteResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *QuerySessionRouteResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *QuerySessionRouteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QuerySessionRouteResult) Unmarshal(in []byte) error {
	msg := new(imauthroute.QuerySessionRouteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QuerySessionRouteResult) GetSuccess() *imauthroute.QuerySessionRouteResp {
	if !p.IsSetSuccess() {
		return QuerySessionRouteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QuerySessionRouteResult) SetSuccess(x interface{}) {
	p.Success = x.(*imauthroute.QuerySessionRouteResp)
}

func (p *QuerySessionRouteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QuerySessionRouteResult) GetResult() interface{} {
	return p.Success
}

func queryUserRouteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(imauthroute.QueryUserRouteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(imauthroute.IMAuthRoute).QueryUserRoute(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QueryUserRouteArgs:
		success, err := handler.(imauthroute.IMAuthRoute).QueryUserRoute(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QueryUserRouteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQueryUserRouteArgs() interface{} {
	return &QueryUserRouteArgs{}
}

func newQueryUserRouteResult() interface{} {
	return &QueryUserRouteResult{}
}

type QueryUserRouteArgs struct {
	Req *imauthroute.QueryUserRouteReq
}

func (p *QueryUserRouteArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(imauthroute.QueryUserRouteReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *QueryUserRouteArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *QueryUserRouteArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *QueryUserRouteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QueryUserRouteArgs) Unmarshal(in []byte) error {
	msg := new(imauthroute.QueryUserRouteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QueryUserRouteArgs_Req_DEFAULT *imauthroute.QueryUserRouteReq

func (p *QueryUserRouteArgs) GetReq() *imauthroute.QueryUserRouteReq {
	if !p.IsSetReq() {
		return QueryUserRouteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QueryUserRouteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QueryUserRouteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QueryUserRouteResult struct {
	Success *imauthroute.QueryUserRouteResp
}

var QueryUserRouteResult_Success_DEFAULT *imauthroute.QueryUserRouteResp

func (p *QueryUserRouteResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(imauthroute.QueryUserRouteResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *QueryUserRouteResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *QueryUserRouteResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *QueryUserRouteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QueryUserRouteResult) Unmarshal(in []byte) error {
	msg := new(imauthroute.QueryUserRouteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QueryUserRouteResult) GetSuccess() *imauthroute.QueryUserRouteResp {
	if !p.IsSetSuccess() {
		return QueryUserRouteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QueryUserRouteResult) SetSuccess(x interface{}) {
	p.Success = x.(*imauthroute.QueryUserRouteResp)
}

func (p *QueryUserRouteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QueryUserRouteResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Login(ctx context.Context, Req *imauthroute.LoginReq) (r *imauthroute.LoginResp, err error) {
	var _args LoginArgs
	_args.Req = Req
	var _result LoginResult
	if err = p.c.Call(ctx, "Login", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Logout(ctx context.Context, Req *imauthroute.LogoutReq) (r *imauthroute.LogoutResp, err error) {
	var _args LogoutArgs
	_args.Req = Req
	var _result LogoutResult
	if err = p.c.Call(ctx, "Logout", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ForceOffline(ctx context.Context, Req *imauthroute.ForceOfflineReq) (r *imauthroute.ForceOfflineResp, err error) {
	var _args ForceOfflineArgs
	_args.Req = Req
	var _result ForceOfflineResult
	if err = p.c.Call(ctx, "ForceOffline", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QuerySessionRoute(ctx context.Context, Req *imauthroute.QuerySessionRouteReq) (r *imauthroute.QuerySessionRouteResp, err error) {
	var _args QuerySessionRouteArgs
	_args.Req = Req
	var _result QuerySessionRouteResult
	if err = p.c.Call(ctx, "QuerySessionRoute", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QueryUserRoute(ctx context.Context, Req *imauthroute.QueryUserRouteReq) (r *imauthroute.QueryUserRouteResp, err error) {
	var _args QueryUserRouteArgs
	_args.Req = Req
	var _result QueryUserRouteResult
	if err = p.c.Call(ctx, "QueryUserRoute", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
